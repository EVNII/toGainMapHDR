//
//  toGainMapHDR
//  This code will convert HDR photo to gain map HDR photo.
//
//  Created by Luyao Peng on 2024/9/27. Distributed under MIT license.
//

import CoreImage
import Foundation
import Accelerate
import CoreImage.CIFilterBuiltins

let ctx = CIContext()
let help_info = "Usage: toGainMapHDR <source file> <destination folder> <options>\n       default: output HDR-heic with ISO gain map in RGB\n       options:\n         -q <value>: image quality (default: 0.85)\n         -r <value>: SDR tone mapping ratio (≥ 1.0, default: 3.0).\n             ratio = 1.0: keep full highlight details\n             ratio >> 10: lose all highlight details\n         -b <base_image>: specify base image\n         -t <text>: add extra text after the output file name\n         -c <color space>: specify output color space (srgb, p3, rec2020)\n         -d <color depth>: specify output color depth (default: 8)\n         -g: output Apple gain map HDR, which generated by CIFilter\n         -a: output Apple gain map HDR, which generated from ISO gain map\n         -m: export ISO Gain Map HDR in monochrome\n         -i: convert JPEG gain map XMP to ISO 21496-1 format (for Adobe compatibility)\n         -H <value>: scaling Apple gain map, between 1.0 (full size, default) and 2.0 (half size)\n         -s: export tone mapped SDR image without HDR gain map\n         -p: export 10bit PQ HDR heic image\n         -h: export HLG HDR heic image (default in 10bit)\n         -j : export image in JPEG format\n         -help: print help information"
let arguments = CommandLine.arguments
guard arguments.count > 2 else {
    print(help_info)
    exit(1)
}

let url_hdr = URL(fileURLWithPath: arguments[1])
var filename: String?
var filename_jpg: String?
filename = url_hdr.deletingPathExtension().appendingPathExtension("heic").lastPathComponent
filename_jpg = url_hdr.deletingPathExtension().appendingPathExtension("jpg").lastPathComponent

let imageoptions = arguments.dropFirst(3)
var base_image_url : URL?

var imagequality: Double? = 0.85
var tonemappingratio: Float? = 3.0
var tonemappingratio_bool : Bool = false
var base_image_bool : Bool = false
var sdr_export: Bool = false
var pq_export: Bool = false
var hlg_export: Bool = false
var jpg_export: Bool = false
var eight_bit: Bool = false
var ten_bit: Bool = false
var half_size: Bool = false
var scaling_ratio : Float? = 1.0
var gain_map_type1: Bool = false
var gain_map_type2: Bool = false
var hdr_image: CIImage
var monochrome_export: Bool = false
var iso_xmp_export: Bool = false

let read_hdr_image = CIImage(contentsOf: url_hdr, options: [.expandToHDR: true])
if read_hdr_image == nil {
    print("Error: No input image found.")
    exit(1)
}

hdr_image = read_hdr_image!

var sdr_color_space = CGColorSpace.displayP3
var hdr_color_space = CGColorSpace.displayP3_PQ
var hlg_color_space = CGColorSpace.displayP3_HLG

let image_color_space = String(describing: hdr_image.colorSpace)
if image_color_space.contains("709") {
    sdr_color_space = CGColorSpace.itur_709
    hdr_color_space = CGColorSpace.itur_709_PQ
    hlg_color_space = CGColorSpace.itur_709_HLG
}
if image_color_space.contains("sRGB") {
    sdr_color_space = CGColorSpace.itur_709
    hdr_color_space = CGColorSpace.itur_709_PQ
    hlg_color_space = CGColorSpace.itur_709_HLG
}
if image_color_space.contains("2100") {
    sdr_color_space = CGColorSpace.itur_2020_sRGBGamma
    hdr_color_space = CGColorSpace.itur_2100_PQ
    hlg_color_space = CGColorSpace.itur_2100_HLG
}
if image_color_space.contains("2020") {
    sdr_color_space = CGColorSpace.itur_2020_sRGBGamma
    hdr_color_space = CGColorSpace.itur_2100_PQ
    hlg_color_space = CGColorSpace.itur_2100_HLG
}

var index:Int = 0
while index < imageoptions.count {
    let option = arguments[index+3]
    switch option {
    case "-q":
        guard index + 1 < imageoptions.count else {
            print("Error: The -q option requires a valid numeric value.")
            exit(1)
        }
        if let value = Double(arguments[index + 4]) {
            if value > 1 {
                imagequality = value/100
            } else {
                imagequality = value
            }
            index += 1 // Skip the next value
        } else {
            print("Error: The -q option requires a valid numeric value.")
            exit(1)
        }
    case "-r":
        guard index + 1 < imageoptions.count else {
            print("Error: The -r option requires a valid numeric value.")
            exit(1)
        }
        if let value = Float(arguments[index + 4]) {
            tonemappingratio_bool = true
            tonemappingratio = value
            index += 1 // Skip the next value
        } else {
            print("Error: The -r option requires a valid numeric value.")
            exit(1)
        }
    case "-b":
        guard index + 1 < imageoptions.count else {
            print("Error: The -b option requires an argument.")
            exit(1)
        }
        base_image_url = URL(fileURLWithPath: arguments[index + 4])
        base_image_bool = true
        index += 1
    case "-s":
        sdr_export = true
    case "-p":
        pq_export = true
    case "-h":
        hlg_export = true
    case "-j":
        jpg_export = true
    case "-m":
        monochrome_export = true
    case "-i":
        iso_xmp_export = true
    case "-H":
        half_size = true
        guard index + 1 < imageoptions.count else {
            print("Error: The -H option requires a valid numeric value.")
            exit(1)
        }
        if let value = Float(arguments[index + 4]) {
            scaling_ratio = value
            index += 1 // Skip the next value
        } else {
            print("Error: The -H option requires a valid numeric value.")
            exit(1)
        }
    case "-g":
        gain_map_type1 = true
    case "-a":
        gain_map_type2 = true
    case "-d":
        guard index + 1 < imageoptions.count else {
            print("Error: The -d option requires an argument.")
            exit(1)
        }
        let bit_depth_argument = String(arguments[index + 4])
        if bit_depth_argument == "8"{
            index += 1
            eight_bit = true
        } else { if bit_depth_argument == "10"{
            ten_bit = true
            index += 1
        } else {
            print("Error: Color depth must be either 8 or 10.")
            exit (1)
        }}
    case "-t":
        guard index + 1 < imageoptions.count else {
            print("Error: The -n option requires an argument.")
            exit(1)
        }
        let additional_filename = String(arguments[index + 4])
        filename = URL(string: url_hdr.deletingPathExtension().absoluteString+additional_filename)!           .appendingPathExtension("heic").lastPathComponent
        filename_jpg = URL(string: url_hdr.deletingPathExtension().absoluteString+additional_filename)!           .appendingPathExtension("jpg").lastPathComponent
        index += 1
    case "-c":
        guard index + 1 < imageoptions.count else {
            print("Error: The -c option requires color space argument.")
            exit(1)
        }
        let color_space_argument = String(arguments[index + 4])
        let color_space_option = color_space_argument.lowercased()
        switch color_space_option {
            case "srgb","709","rec709","rec.709","bt709","bt.709","itu709":
                sdr_color_space = CGColorSpace.itur_709
                hdr_color_space = CGColorSpace.itur_709_PQ
                hlg_color_space = CGColorSpace.itur_709_HLG
            case "p3","dcip3","dci-p3","dci.p3","displayp3":
                sdr_color_space = CGColorSpace.displayP3
                hdr_color_space = CGColorSpace.displayP3_PQ
                hlg_color_space = CGColorSpace.displayP3_HLG
            case "rec2020","2020","rec.2020","bt2020","itu2020","2100","rec2100","rec.2100":
                sdr_color_space = CGColorSpace.itur_2020_sRGBGamma
                hdr_color_space = CGColorSpace.itur_2100_PQ
                hlg_color_space = CGColorSpace.itur_2100_HLG
            default:
                print("Error: The -c option requires color space argument. (srgb, p3, rec2020)")
                exit(1)
        }
        index += 1
    case "-help":
        print(help_info)
        exit(1)
    default:
        print("Warrning: Unknown option: \(option)")
    }
    index += 1
}


let path_export = URL(fileURLWithPath: arguments[2])
let url_export_heic = path_export.appendingPathComponent(filename!)
let url_export_jpg = path_export.appendingPathComponent(filename_jpg!)

if [pq_export, hlg_export, sdr_export, gain_map_type1, gain_map_type2].filter({$0}).count >= 2 {
    print("Error: Only one export format can be used.")
    exit(1)
}
if base_image_bool && sdr_export {
     print("Error: Base image cannot be used with SDR export.")
     exit(1)
}
if (jpg_export && hlg_export) || (jpg_export && pq_export) {
    print("Error: Not support exporting JPEG with HLG or PQ transfer function.")
    exit(1)
}
if tonemappingratio! < 1.0 {
    print("Error: The -r option requires a valid numeric value.")
    exit(1)
}
if imagequality! < 0 || imagequality! > 1 {
    print("Error: The -q option requires a valid numeric value.")
    exit(1)
}
if scaling_ratio! < 1 || scaling_ratio! > 2 {
    print("Error: The -H option requires a valid numeric value.")
    exit(1)
}


if hlg_export && eight_bit {print("Warrning: Suggested to use 10-bit with HLG.")}
if jpg_export && ten_bit {print("Warning: Color depth will be 8 when exporting JPEG.")}
if pq_export && eight_bit {print("Warning: Color depth will be 10 when exporting PQ HDR.")}
if tonemappingratio_bool && base_image_bool {print("Warrning: Base image specified, tone mapping ratio will not be applied.")}
if tonemappingratio_bool && hlg_export {print("Warrning: Tone mapping ratio will not be applied when exporting HLG HDR image.")}
if tonemappingratio_bool && pq_export {print("Warrning: Tone mapping ratio will not be applied when exporting PQ HDR image.")}
if half_size && !gain_map_type1 && !gain_map_type2 {print("Warrning: Only Apple gain map format support half size gain map.")}
// if base_image_bool && monochrome_export {print("Warrning: Base image specified, will use RGB gain map.")}

if base_image_bool {
    if let base_img = CIImage(contentsOf: base_image_url!) {
        let base_headroom = maxLuminance(from: base_img) ?? 0.0
        if base_headroom > 1.05 {
             print("Warning: Base image headroom: \(base_headroom). EDR base will be converted to SDR for gain map generation.")
        }
    }
}
if monochrome_export {
    print("Warning: Monochrome Gain Map is not fully supported by all viewers. Forcing RGB Gain Map for compatibility.")
}


// export hlg and pq hdr file
while hlg_export{
    let hlg_export_options = NSDictionary(dictionary:[kCGImageDestinationLossyCompressionQuality:imagequality ?? 0.85])
    if eight_bit {
        try! ctx.writeHEIFRepresentation(of: hdr_image,
                                         to: url_export_heic,
                                         format: CIFormat.RGBA8,
                                         colorSpace: CGColorSpace(name: hlg_color_space)!,
                                         options:hlg_export_options as! [CIImageRepresentationOption : Any])
    } else {
        try! ctx.writeHEIF10Representation(of: hdr_image,
                                         to: url_export_heic,
                                         colorSpace: CGColorSpace(name: hlg_color_space)!,
                                         options:hlg_export_options as! [CIImageRepresentationOption : Any])
    }
    exit(0)
}

while pq_export {
    let pq_export_options = NSDictionary(dictionary:[kCGImageDestinationLossyCompressionQuality:imagequality ?? 0.85])
    try! ctx.writeHEIF10Representation(of: hdr_image,
                                       to: url_export_heic,
                                       colorSpace: CGColorSpace(name: hdr_color_space)!,
                                       options:pq_export_options as! [CIImageRepresentationOption : Any])
    exit(0)
}


// Custom filter

private func getGainMap(hdr_input: CIImage,sdr_input: CIImage,hdr_max: Float) -> CIImage {
    let filter = GainMapFilter()
    filter.HDRImage = hdr_input
    filter.SDRImage = sdr_input
    filter.hdrmax = hdr_max
    let outputImage = filter.outputImage
    return outputImage!
}

func lanczosResizeImage(originalImage: CIImage, ratio: Float) -> CIImage {
    let lanczosScaleFilter = CIFilter.lanczosScaleTransform()
    lanczosScaleFilter.inputImage = originalImage
    lanczosScaleFilter.scale =  1.0/ratio
    lanczosScaleFilter.aspectRatio = 1
    return lanczosScaleFilter.outputImage!
}

func maxLuminance(from ciImage: CIImage) -> Float? {
    let extent = ciImage.extent
    let filter = CIFilter.areaMaximum()
    filter.inputImage = ciImage
    filter.extent = extent
    
    guard let outputImage = filter.outputImage else { return nil }
    
    // Use floating point format to preserve HDR values
    var bitmap = [Float](repeating: 0, count: 4)
    ctx.render(outputImage,
                   toBitmap: &bitmap,
                   rowBytes: MemoryLayout<Float>.size * 4,
                   bounds: CGRect(x: 0, y: 0, width: 1, height: 1),
                   format: .RGBAf,
                   colorSpace: nil)
    
    let r = bitmap[0]
    let g = bitmap[1]
    let b = bitmap[2]
    
    let luminance: Float = max(r,g,b)
    return luminance
}


var pic_headroom : Float
var pic_headroom2 : Float
var headroom_ratio : Float
var tonemapped_sdrimage : CIImage?
var sdr_headroom : Float

pic_headroom = maxLuminance(from: hdr_image)!

let transform = CGAffineTransform(scaleX: 1.0 / CGFloat(tonemappingratio!), y: 1.0 / CGFloat(tonemappingratio!))
pic_headroom2 = maxLuminance(from: hdr_image.transformed(by: transform))!

if pic_headroom < 1.05 {
    print("Warning: Picture headroom < 1.05, this is a SDR image, outputing SDR image.")
    sdr_export = true
    base_image_bool = false
    headroom_ratio = 1.0
}

if pic_headroom2 < 1.0 {
    pic_headroom2 = 1.0
}

headroom_ratio = pic_headroom2


func generate_sdr_image() -> CIImage?{
    if base_image_bool {
        if CIImage(contentsOf: base_image_url!) == nil {
            print("Warning: Could not load base image, will generate base image by tone mapping.")
            base_image_bool = false
            return hdr_image.applyingFilter("CIToneMapHeadroom", parameters: ["inputSourceHeadroom":headroom_ratio,"inputTargetHeadroom":1.0])
        }
            // Apply a no-op filter to strip source metadata (like Exif) from the base image
            // This ensures it behaves like a generated image, preventing potential metadata conflicts
            let base = CIImage(contentsOf: base_image_url!)
            if (maxLuminance(from: base!) ?? 1.0) > 1.05 {
                 print("Warning: Base image is EDR (headroom > 1.05). Rendering to 8-bit SDR for gain map generation.")
                 
                 // CIImage filters are lazy — clamping alone doesn't strip EDR properties.
                 // Force pixel materialization by rendering to a CGImage in the target SDR color space.
                 let clamped = base!.applyingFilter("CIColorClamp", parameters: [
                     "inputMinComponents": CIVector(x: 0, y: 0, z: 0, w: 0),
                     "inputMaxComponents": CIVector(x: 1, y: 1, z: 1, w: 1)
                 ])
                 if let cgImage = ctx.createCGImage(clamped, from: clamped.extent, format: .RGBA8, colorSpace: CGColorSpace(name: sdr_color_space)!) {
                     return CIImage(cgImage: cgImage)
                 }
                 // Fallback: return clamped with no-op filter
                 return clamped.applyingFilter("CIGammaAdjust", parameters: ["inputPower": 1.0])
            }
            return base?.applyingFilter("CIGammaAdjust", parameters: ["inputPower": 1.0])
    }
    if gain_map_type1 {
        return hdr_image.applyingFilter("CIToneMapHeadroom", parameters: ["inputSourceHeadroom":headroom_ratio,"inputTargetHeadroom":1.0])
    }
    return hdr_image.applyingFilter("CIToneMapHeadroom", parameters: ["inputSourceHeadroom":headroom_ratio,"inputTargetHeadroom":1.0])
}

tonemapped_sdrimage = generate_sdr_image()!

while sdr_export{
    let sdr_export_options = NSDictionary(dictionary:[kCGImageDestinationLossyCompressionQuality:imagequality ?? 0.85])
    if jpg_export{
        try! ctx.writeJPEGRepresentation(of: tonemapped_sdrimage!,
                                         to: url_export_jpg,
                                         colorSpace: CGColorSpace(name: sdr_color_space)!,
                                         options:sdr_export_options as! [CIImageRepresentationOption : Any])
    } else {
        if ten_bit{
            try! ctx.writeHEIF10Representation(of: tonemapped_sdrimage!,
                                               to: url_export_heic,
                                               colorSpace: CGColorSpace(name: sdr_color_space)!,
                                               options:sdr_export_options as! [CIImageRepresentationOption : Any])
        } else {
            try! ctx.writeHEIFRepresentation(of: tonemapped_sdrimage!,
                                             to: url_export_heic,
                                             format: CIFormat.RGBA8,
                                             colorSpace: CGColorSpace(name: sdr_color_space)!,
                                             options:sdr_export_options as! [CIImageRepresentationOption : Any])
        }
    }
    exit(0)
}

// -b: export RGB gain map image with specified base image (ISO format)
if base_image_bool && !gain_map_type1 && !gain_map_type2 {
    let rgb_export_options = NSDictionary(dictionary:[kCGImageDestinationLossyCompressionQuality:imagequality ?? 0.85, CIImageRepresentationOption.hdrImage:hdr_image,CIImageRepresentationOption.hdrGainMapAsRGB:!monochrome_export])
    
    if jpg_export {
        try! ctx.writeJPEGRepresentation(of: tonemapped_sdrimage!,
                                         to: url_export_jpg,
                                         colorSpace: CGColorSpace(name: sdr_color_space)!,
                                         options: rgb_export_options as! [CIImageRepresentationOption : Any])
    } else {
        if ten_bit {
            try! ctx.writeHEIF10Representation(of: tonemapped_sdrimage!,
                                               to: url_export_heic,
                                               colorSpace: CGColorSpace(name: sdr_color_space)!,
                                               options: rgb_export_options as! [CIImageRepresentationOption : Any])
        } else {
            try! ctx.writeHEIFRepresentation(of: tonemapped_sdrimage!,
                                             to: url_export_heic,
                                             format: CIFormat.RGBA8,
                                             colorSpace: CGColorSpace(name: sdr_color_space)!,
                                             options: rgb_export_options as! [CIImageRepresentationOption : Any])
        }
    }
    if iso_xmp_export && jpg_export { convertToISOGainMapXMP(at: url_export_jpg) }
    exit(0)
}

// export adaptive gain map image (default format)
if !gain_map_type1 && !gain_map_type2 {
    var adaptive_export_options: NSDictionary
    if monochrome_export {
        adaptive_export_options = NSDictionary(dictionary:[kCGImageDestinationLossyCompressionQuality:imagequality ?? 0.85, CIImageRepresentationOption.hdrImage:hdr_image,CIImageRepresentationOption.hdrGainMapAsRGB:true])
    } else {
        adaptive_export_options = NSDictionary(dictionary:[kCGImageDestinationLossyCompressionQuality:imagequality ?? 0.85, CIImageRepresentationOption.hdrImage:hdr_image,CIImageRepresentationOption.hdrGainMapAsRGB:true])
    }
    if jpg_export {
        try! ctx.writeJPEGRepresentation(of: tonemapped_sdrimage!,
                                         to: url_export_jpg,
                                         colorSpace: CGColorSpace(name: sdr_color_space)!,
                                         options: adaptive_export_options as! [CIImageRepresentationOption : Any])
    } else {
        if ten_bit {
            try! ctx.writeHEIF10Representation(of: tonemapped_sdrimage!,
                                               to: url_export_heic,
                                               colorSpace: CGColorSpace(name: sdr_color_space)!,
                                               options: adaptive_export_options as! [CIImageRepresentationOption : Any])
        } else {
            try! ctx.writeHEIFRepresentation(of: tonemapped_sdrimage!,
                                             to: url_export_heic,
                                             format: CIFormat.RGBA8,
                                             colorSpace: CGColorSpace(name: sdr_color_space)!,
                                             options: adaptive_export_options as! [CIImageRepresentationOption : Any])
        }
    }
    if iso_xmp_export && jpg_export { convertToISOGainMapXMP(at: url_export_jpg) }
    exit(0)
}

// -g: gain map type I, generate Apple HDR gain map by CIFilter
if gain_map_type1 {
    var gain_map : CIImage
    gain_map = getGainMap(hdr_input: hdr_image, sdr_input: tonemapped_sdrimage!, hdr_max: pic_headroom)

    if half_size{
        gain_map = lanczosResizeImage(originalImage: gain_map, ratio: scaling_ratio!)
    }
    
    let stops = log2(pic_headroom)
    var imageProperties = hdr_image.properties
    var makerApple = imageProperties[kCGImagePropertyMakerAppleDictionary as String] as? [String: Any] ?? [:]

    switch stops {
    case let x where x >= 2.303:
        makerApple["33"] = 1.0
        makerApple["48"] = (3.0 - stops)/70.0
    case 1.8..<3:
        makerApple["33"] = 1.0
        makerApple["48"] = (2.303 - stops)/0.303
    case 1.6..<1.8:
        makerApple["33"] = 0.0
        makerApple["48"] = (1.80 - stops)/20.0
    default:
        makerApple["33"] = 0.0
        makerApple["48"] = (1.601 - stops)/0.101
    }
    
    imageProperties[kCGImagePropertyMakerAppleDictionary as String] = makerApple
    let modifiedImage = tonemapped_sdrimage!.settingProperties(imageProperties)

    let alt_export_options = NSDictionary(dictionary:[kCGImageDestinationLossyCompressionQuality:imagequality ?? 0.85, CIImageRepresentationOption.hdrGainMapImage:gain_map])
    if jpg_export {
        try! ctx.writeJPEGRepresentation(of: modifiedImage,
                                         to: url_export_jpg,
                                         colorSpace: CGColorSpace(name: sdr_color_space)!,
                                         options:alt_export_options as! [CIImageRepresentationOption : Any])
    } else {
        if ten_bit {
            try! ctx.writeHEIF10Representation(of: modifiedImage,
                                               to: url_export_heic,
                                               colorSpace: CGColorSpace(name: sdr_color_space)!,
                                               options: alt_export_options as! [CIImageRepresentationOption : Any])
        } else {
            try! ctx.writeHEIFRepresentation(of: modifiedImage,
                                             to: url_export_heic,
                                             format: CIFormat.RGBA8,
                                             colorSpace: CGColorSpace(name: sdr_color_space)!,
                                             options: alt_export_options as! [CIImageRepresentationOption : Any])
        }
    }
    if iso_xmp_export && jpg_export { convertToISOGainMapXMP(at: url_export_jpg) }
    exit(0)
}

// gain map type II: generate Apple HDR gain map from ISO gain map


let tmp_export_options = NSDictionary(dictionary:[ CIImageRepresentationOption.hdrImage:hdr_image,CIImageRepresentationOption.hdrGainMapAsRGB:false])
let tmp_heic_data = ctx.heifRepresentation(of: tonemapped_sdrimage!,
                                           format: CIFormat.RGBA8,
                                           colorSpace: CGColorSpace(name: sdr_color_space)!,
                                           options: tmp_export_options as! [CIImageRepresentationOption : Any])

var tmp_gainmap_data : CIImage
tmp_gainmap_data = CIImage(data: tmp_heic_data!, options: [.init(rawValue: "kCIImageAuxiliaryHDRGainMap"): true])!
if half_size {
    tmp_gainmap_data = lanczosResizeImage(originalImage: tmp_gainmap_data, ratio: scaling_ratio!)
}
let apple_export_options = NSDictionary(dictionary:[kCGImageDestinationLossyCompressionQuality:imagequality ?? 0.85, CIImageRepresentationOption.hdrGainMapImage:tmp_gainmap_data as Any])

var imageproperties = hdr_image.properties
var makerapple = imageproperties[kCGImagePropertyMakerAppleDictionary as String] as? [String: Any] ?? [:]

makerapple["33"] = 1.01
makerapple["48"] = 0.009986
imageproperties[kCGImagePropertyMakerAppleDictionary as String] = makerapple

let modifiedimage = tonemapped_sdrimage!.settingProperties(imageproperties)

if jpg_export {
    try! ctx.writeJPEGRepresentation(of: modifiedimage,
                                     to: url_export_jpg,
                                     colorSpace: CGColorSpace(name: sdr_color_space)!,
                                     options:apple_export_options as! [CIImageRepresentationOption : Any])
} else {
    if ten_bit {
        try! ctx.writeHEIF10Representation(of: modifiedimage,
                                           to: url_export_heic,
                                           colorSpace: CGColorSpace(name: sdr_color_space)!,
                                           options: apple_export_options as! [CIImageRepresentationOption : Any])
    } else {
        try! ctx.writeHEIFRepresentation(of: modifiedimage,
                                         to: url_export_heic,
                                         format: CIFormat.RGBA8,
                                         colorSpace: CGColorSpace(name: sdr_color_space)!,
                                         options: apple_export_options as! [CIImageRepresentationOption : Any])
    }
}

//let filename2 = url_hdr.deletingPathExtension().appendingPathExtension("png").lastPathComponent
//let url_export_heic2 = path_export.appendingPathComponent(filename2)
//try! ctx.writePNGRepresentation(of: sdr_image!, to: url_export_heic2, format: CIFormat.RGBA8, colorSpace:CGColorSpace(name: CGColorSpace.displayP3)!)
exit(0)

// MARK: - ISO 21496-1 XMP Conversion
// Converts Apple's HDRToneMap XMP format to ISO 21496-1 hdrgm format in JPEG files.
// The Adobe Gain Map Demo App requires this format to display gain map layers from JPEG.

func convertToISOGainMapXMP(at url: URL) {
    guard let fileData = try? Data(contentsOf: url) else { return }
    let result = processJPEGForISO(fileData)
    try? result.write(to: url, options: .atomic)
    print("Converted JPEG gain map XMP to ISO 21496-1 format.")
}


func processJPEGForISO(_ data: Data, isSecondary: Bool = false) -> Data {
    var result = Data()
    var i = 0
    var firstXMP = true
    guard data.count >= 2, data[0] == 0xFF, data[1] == 0xD8 else { return data }
    result.append(contentsOf: data[0..<2])
    i = 2

    while i < data.count - 1 {
        guard data[i] == 0xFF else { result.append(data[i]); i += 1; continue }
        let marker = data[i + 1]

        // RST markers (no length)
        if marker >= 0xD0 && marker <= 0xD7 || marker == 0x01 {
            result.append(contentsOf: data[i..<(i+2)]); i += 2; continue
        }

        // EOI - check for secondary image (MPF gain map)
        if marker == 0xD9 {
            result.append(contentsOf: [0xFF, 0xD9]); i += 2
            if i < data.count - 1, data[i] == 0xFF, data[i+1] == 0xD8 {
                result.append(processJPEGForISO(Data(data[i...]), isSecondary: true))
            }
            return result
        }

        // SOS - copy header + entropy-coded data
        if marker == 0xDA {
            guard i + 3 < data.count else { result.append(contentsOf: data[i...]); return result }
            let sLen = (Int(data[i+2]) << 8) | Int(data[i+3])
            let sEnd = min(i + 2 + sLen, data.count)
            result.append(contentsOf: data[i..<sEnd])
            var j = sEnd
            while j < data.count {
                if data[j] == 0xFF, j + 1 < data.count {
                    let nm = data[j + 1]
                    if nm == 0x00 || (nm >= 0xD0 && nm <= 0xD7) {
                        result.append(contentsOf: data[j..<(j+2)]); j += 2
                    } else { break }
                } else { result.append(data[j]); j += 1 }
            }
            i = j; continue
        }

        // Regular segment with length
        guard i + 3 < data.count else { result.append(contentsOf: data[i...]); return result }
        let segLen = (Int(data[i+2]) << 8) | Int(data[i+3])
        let segEnd = min(i + 2 + segLen, data.count)

        // APP1 - check for XMP
        if marker == 0xE1 {
            let contentStart = i + 4
            let xmpId = Data("http://ns.adobe.com/xap/1.0/\0".utf8)
            if segLen > xmpId.count + 2, contentStart + xmpId.count <= segEnd,
               data[contentStart..<(contentStart + xmpId.count)] == xmpId {
                let xmpStart = contentStart + xmpId.count
                if var xmpStr = String(data: data[xmpStart..<segEnd], encoding: .utf8) {
                    let origLen = data[xmpStart..<segEnd].count
                    
                    if firstXMP && !isSecondary {
                        // Primary image XMP: inject hdrgm namespace for macOS HDR detection
                        xmpStr = injectHdrgmNamespace(xmpStr)
                        firstXMP = false
                    } else {
                        // Gain map image XMP: convert Apple format to ISO
                        xmpStr = applyISOReplacements(xmpStr)
                    }
                    
                    var newXmpData = Data(xmpStr.utf8)
                    // Pad or trim to keep same size
                    if newXmpData.count < origLen {
                        newXmpData.append(Data(repeating: 0x20, count: origLen - newXmpData.count))
                    } else if newXmpData.count > origLen {
                        newXmpData = newXmpData.prefix(origLen)
                    }
                    // Write APP1 with same length
                    result.append(contentsOf: [0xFF, marker])
                    result.append(data[i+2]); result.append(data[i+3]) // same length
                    result.append(xmpId)
                    result.append(newXmpData)
                    i = segEnd; continue
                }
            }
        }

        // APP2 - check for MPF, inject ISO URN after it
        if marker == 0xE2 {
            let contentStart = i + 4
            let mpfId = Data("MPF\0".utf8)
            result.append(contentsOf: data[i..<segEnd])
            i = segEnd
            // If this is the MPF segment, inject ISO URN APP2 right after
            if contentStart + mpfId.count <= segEnd,
               data[contentStart..<(contentStart + mpfId.count)] == mpfId {
                var urnPayload = Data("urn:iso:std:iso:ts:21496:-1".utf8)
                urnPayload.append(contentsOf: [0x00, 0x00, 0x00, 0x00, 0x00]) // null + padding (matches reference)
                let urnLen = urnPayload.count + 2
                result.append(contentsOf: [0xFF, 0xE2]) // APP2 marker
                result.append(UInt8((urnLen >> 8) & 0xFF))
                result.append(UInt8(urnLen & 0xFF))
                result.append(urnPayload)
            }
            continue
        }

        // Copy segment as-is
        result.append(contentsOf: data[i..<segEnd])
        i = segEnd
    }
    if i < data.count { result.append(contentsOf: data[i...]) }
    return result
}

func applyISOReplacements(_ xmp: String) -> String {
    // Parse values from Apple's XMP format
    func extractValue(_ tag: String, from s: String) -> String? {
        let open = "<HDRToneMap:\(tag)>"
        let close = "</HDRToneMap:\(tag)>"
        guard let start = s.range(of: open), let end = s.range(of: close) else { return nil }
        return String(s[start.upperBound..<end.lowerBound])
    }
    func extractChannelValues(_ tag: String, from s: String) -> [String] {
        var values: [String] = []
        var search = s.startIndex
        let open = "<HDRToneMap:\(tag)>"
        let close = "</HDRToneMap:\(tag)>"
        while let start = s.range(of: open, range: search..<s.endIndex),
              let end = s.range(of: close, range: start.upperBound..<s.endIndex) {
            values.append(String(s[start.upperBound..<end.lowerBound]))
            search = end.upperBound
        }
        return values
    }

    let capacityMax = extractValue("AlternateHeadroom", from: xmp) ?? "1.0"
    let capacityMin = extractValue("BaseHeadroom", from: xmp) ?? "0.0"
    let baseIsHDR = extractValue("BaseRenditionIsHDR", from: xmp) ?? "0"
    let version = extractValue("Version", from: xmp) ?? "1"
    let gainMapMin = extractChannelValues("GainMapMin", from: xmp)
    let gainMapMax = extractChannelValues("GainMapMax", from: xmp)
    let gamma = extractChannelValues("Gamma", from: xmp)
    let offsetSDR = extractChannelValues("OffsetSDR", from: xmp)
    let offsetHDR = extractChannelValues("OffsetHDR", from: xmp)
    
    let baseIsHDRStr = (baseIsHDR == "0" || baseIsHDR == "false") ? "False" : "True"

    func rdfSeq(_ values: [String]) -> String {
        if values.isEmpty { return "<rdf:Seq/>" }
        let items = values.map { "     <rdf:li>\($0)</rdf:li>" }.joined(separator: "\n")
        return "<rdf:Seq>\n\(items)\n    </rdf:Seq>"
    }

    // Build ISO 21496-1 compliant XMP (matching Lightroom's format)
    return """
<?xpacket begin="\u{feff}" id="W5M0MpCehiHzreSzNTczkc9d"?>
<x:xmpmeta xmlns:x="adobe:ns:meta/">
 <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
  <rdf:Description rdf:about=""
    xmlns:hdrgm="http://ns.adobe.com/hdr-gain-map/1.0/"
   hdrgm:Version="1.0"
   hdrgm:BaseRenditionIsHDR="\(baseIsHDRStr)"
   hdrgm:HDRCapacityMin="\(capacityMin)"
   hdrgm:HDRCapacityMax="\(capacityMax)"
   hdrgm:OffsetSDR="\(offsetSDR.first ?? "0.000010")"
   hdrgm:OffsetHDR="\(offsetHDR.first ?? "0.000010")">
   <hdrgm:GainMapMin>
    \(rdfSeq(gainMapMin))
   </hdrgm:GainMapMin>
   <hdrgm:GainMapMax>
    \(rdfSeq(gainMapMax))
   </hdrgm:GainMapMax>
   <hdrgm:Gamma>
    \(rdfSeq(gamma))
   </hdrgm:Gamma>
  </rdf:Description>
 </rdf:RDF>
</x:xmpmeta>
<?xpacket end="w"?>
"""
}

func injectHdrgmNamespace(_ xmp: String) -> String {
    var s = xmp
    // Add hdrgm namespace and Version to rdf:Description for macOS HDR detection
    let nsDecl = "xmlns:hdrgm=\"http://ns.adobe.com/hdr-gain-map/1.0/\" hdrgm:Version=\"1.0\""
    if let range = s.range(of: "rdf:about=\"\"") {
        s = s.replacingCharacters(in: range, with: "rdf:about=\"\" \(nsDecl)")
    }
    return s
}

// debug
//let filename2 = url_hdr.deletingPathExtension().appendingPathExtension("png").lastPathComponent
//let url_export_heic2 = path_export.appendingPathComponent(filename2)
//try! ctx.writePNGRepresentation(of: gainmap!, to: url_export_heic2, format: CIFormat.RGBA8, colorSpace:CGColorSpace(name: CGColorSpace.displayP3)!)
exit(0)
